
// Premium Chart Engine - Trading-Style Visuals
// Supports: 'line' (smooth), 'bar' (gradient)
class Chart {
    constructor(ctx, config) {
        this.ctx = ctx;
        this.config = config;
        this.canvas = ctx.canvas;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.padding = { top: 20, right: 20, bottom: 35, left: 45 };
        this.animationProgress = 0;

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = this.canvas.offsetWidth * dpr;
        this.canvas.height = this.canvas.offsetHeight * dpr;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.ctx.scale(dpr, dpr);
        this.width = this.canvas.offsetWidth;
        this.height = this.canvas.offsetHeight;

        this.animate();
    }

    animate() {
        const duration = 800; // ms
        const start = performance.now();

        const step = (timestamp) => {
            this.animationProgress = Math.min((timestamp - start) / duration, 1);
            this.animationProgress = this.easeOutCubic(this.animationProgress);
            this.draw();
            if (this.animationProgress < 1) {
                requestAnimationFrame(step);
            }
        };
        requestAnimationFrame(step);
    }

    easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.width, this.height);

        const type = this.config.type;
        const data = this.config.data;

        if (!data || !data.datasets || !data.datasets.length) {
            this.drawText("No Data Available");
            return;
        }

        const labels = data.labels || [];
        const dataset = data.datasets[0];
        const values = dataset.data || [];
        const color = dataset.borderColor || dataset.backgroundColor || '#10b981';

        let maxVal = Math.max(...values, 1) * 1.15;

        // Draw Grid First
        this.drawGrid(values.length, maxVal);

        if (type === 'line') {
            this.drawLineChart(values, labels, maxVal, color);
        } else if (type === 'bar') {
            this.drawBarChart(values, labels, maxVal, color);
        }

        // Draw Labels Last (on top)
        this.drawXLabels(labels);
    }

    drawGrid(numPoints, maxVal) {
        const ctx = this.ctx;
        const chartWidth = this.width - this.padding.left - this.padding.right;
        const chartHeight = this.height - this.padding.top - this.padding.bottom;

        // Horizontal grid lines (5 lines)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
        ctx.lineWidth = 1;

        for (let i = 0; i <= 4; i++) {
            const y = this.padding.top + (chartHeight / 4) * i;
            ctx.beginPath();
            ctx.moveTo(this.padding.left, y);
            ctx.lineTo(this.width - this.padding.right, y);
            ctx.stroke();

            // Y-axis labels
            const val = maxVal - (maxVal / 4) * i;
            ctx.fillStyle = 'rgba(148, 163, 184, 0.6)';
            ctx.font = '10px system-ui, sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(val >= 1000 ? (val / 1000).toFixed(1) + 'k' : Math.round(val), this.padding.left - 8, y + 4);
        }
    }

    drawLineChart(values, labels, maxVal, color) {
        const ctx = this.ctx;
        const chartWidth = this.width - this.padding.left - this.padding.right;
        const chartHeight = this.height - this.padding.top - this.padding.bottom;
        const stepX = chartWidth / Math.max(values.length - 1, 1);

        const points = values.map((v, i) => ({
            x: this.padding.left + i * stepX,
            y: this.padding.top + chartHeight - (v / maxVal * chartHeight * this.animationProgress)
        }));

        // Gradient Fill Under Curve
        const gradient = ctx.createLinearGradient(0, this.padding.top, 0, this.height - this.padding.bottom);
        gradient.addColorStop(0, this.hexToRgba(color, 0.4));
        gradient.addColorStop(0.5, this.hexToRgba(color, 0.1));
        gradient.addColorStop(1, this.hexToRgba(color, 0));

        // Draw Smooth Curve (Bezier)
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        for (let i = 0; i < points.length - 1; i++) {
            const xc = (points[i].x + points[i + 1].x) / 2;
            const yc = (points[i].y + points[i + 1].y) / 2;
            ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        // Last point
        ctx.quadraticCurveTo(points[points.length - 1].x, points[points.length - 1].y, points[points.length - 1].x, points[points.length - 1].y);

        // Fill Area
        ctx.lineTo(points[points.length - 1].x, this.height - this.padding.bottom);
        ctx.lineTo(points[0].x, this.height - this.padding.bottom);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw Glow Effect
        ctx.shadowColor = color;
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // Draw Line on Top
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 0; i < points.length - 1; i++) {
            const xc = (points[i].x + points[i + 1].x) / 2;
            const yc = (points[i].y + points[i + 1].y) / 2;
            ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        ctx.quadraticCurveTo(points[points.length - 1].x, points[points.length - 1].y, points[points.length - 1].x, points[points.length - 1].y);

        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();

        // Reset Shadow
        ctx.shadowBlur = 0;

        // Draw Data Points
        points.forEach((p, i) => {
            // Outer glow
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = this.hexToRgba(color, 0.3);
            ctx.fill();

            // Inner dot
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#0f172a';
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        });
    }

    drawBarChart(values, labels, maxVal, color) {
        const ctx = this.ctx;
        const chartWidth = this.width - this.padding.left - this.padding.right;
        const chartHeight = this.height - this.padding.top - this.padding.bottom;
        const barGap = 8;
        const barWidth = (chartWidth / values.length) - barGap;

        values.forEach((v, i) => {
            const barHeight = (v / maxVal * chartHeight) * this.animationProgress;
            const x = this.padding.left + i * (barWidth + barGap) + barGap / 2;
            const y = this.padding.top + chartHeight - barHeight;

            // Gradient Bar
            const barGradient = ctx.createLinearGradient(x, y, x, y + barHeight);
            barGradient.addColorStop(0, color);
            barGradient.addColorStop(1, this.hexToRgba(color, 0.5));

            // Glow
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;

            // Rounded Rectangle
            this.roundRect(ctx, x, y, barWidth, barHeight, 4);
            ctx.fillStyle = barGradient;
            ctx.fill();

            ctx.shadowBlur = 0;
        });
    }

    drawXLabels(labels) {
        const ctx = this.ctx;
        const chartWidth = this.width - this.padding.left - this.padding.right;
        const stepX = chartWidth / Math.max(labels.length - 1, 1);

        ctx.fillStyle = 'rgba(148, 163, 184, 0.7)';
        ctx.font = '10px system-ui, sans-serif';
        ctx.textAlign = 'center';

        labels.forEach((label, i) => {
            const x = this.padding.left + i * stepX;
            ctx.fillText(label, x, this.height - 10);
        });
    }

    roundRect(ctx, x, y, w, h, r) {
        if (h < 0) return; // Skip if no height
        r = Math.min(r, h / 2, w / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }

    hexToRgba(hex, alpha) {
        if (hex.startsWith('rgb')) {
            return hex.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
        }
        let c = hex.replace('#', '');
        if (c.length === 3) c = c[0] + c[0] + c[1] + c[1] + c[2] + c[2];
        const r = parseInt(c.substring(0, 2), 16);
        const g = parseInt(c.substring(2, 4), 16);
        const b = parseInt(c.substring(4, 6), 16);
        return `rgba(${r},${g},${b},${alpha})`;
    }

    drawText(text) {
        const ctx = this.ctx;
        ctx.fillStyle = "rgba(148, 163, 184, 0.5)";
        ctx.font = "14px system-ui, sans-serif";
        ctx.textAlign = 'center';
        ctx.fillText(text, this.width / 2, this.height / 2);
    }

    destroy() {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }
}
